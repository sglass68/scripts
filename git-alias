get_branch_old() {
	local branch=$(git symbolic-ref HEAD 2>/dev/null |awk -F / '{print $3}')
	#local branch=$(git name-rev --name-only HEAD)
	if [ -z "${branch}" ]; then
		branch=$(git name-rev @{-1} --name-only)
		echo "Warning: Using branch ${branch}" >/dev/stderr
	fi

	local remote=$(git config -l | \
		sed -n "s#branch.${branch}.remote=\(.*\)#\1#p")
	local merge=$(git config -l | \
		sed -n "s#branch.${branch}.merge=refs/heads/\(.*\)#\1#p")
	[ -n "${remote}${merge}" ] || (
		echo "Error: No tracking branch" >/dev/stderr;
		echo "Use 'git branch --set-upstream ${branch} upstream/foo'" \
			>/dev/stderr;
		echo >/dev/stderr;
		return 1)
	if [ "${remote}" == "." ]; then
	        echo ${merge}
 	else
		echo ${remote}/${merge}
	fi
}

get_branch() {
	# try @{upstream} first since it is easy
	upstream=$(git name-rev @{upstream} --name-only 2>/dev/null)
	if [ -z "${upstream}" ]; then
		upstream=$(git log --oneline  -n 50 |grep git5track |head -1 |cut -f 1 -d " ")
	fi
	if [ -n "${upstream}" ]; then
		echo ${upstream}
		return
	fi
	# maybe we are in the middle of a rebase
	upstream=$(git name-rev @{-1} --name-only)
	echo "Warning: Using upstream branch ${upstream}" >/dev/stderr

	local remote=$(git config -l | \
		sed -n "s#branch.${upstream}.remote=\(.*\)#\1#p")
	local merge=$(git config -l | \
		sed -n "s#branch.${upstream}.merge=refs/heads/\(.*\)#\1#p")
	[ -n "${remote}${merge}" ] || (
		echo "Error: No tracking branch" >/dev/stderr;
		echo "Use 'git branch --set-upstream ${upstream} upstream/foo'" \
			>/dev/stderr;
		echo >/dev/stderr;
		return 1)
	if [ "${remote}" == "." ]; then
		echo ${merge}
	else
		echo ${remote}/${merge}
	fi
}

# show changed made in top commit (useful when working through a rebase -i)
alias dh='git diff HEAD~'

# move to next commit during a rebase
alias rc='git rebase --continue'
alias rs='git rebase --skip'

# add all changed files
alias au='git add -u'


git_log_oneline() {
	if [ $# -eq 0 ]; then
		git log --oneline --decorate $(get_branch).. $@
	else
		git log --oneline --decorate $@
	fi
}

# show short list of commits in this branch
alias ol='git_log_oneline'

# show stat log of commits in this branch
alias sl='git log --stat $(get_branch)..'

# commit
alias gc='git commit'

# amend - useful during rebase also
alias am='git commit --amend'

# type this a lot
alias g='git status -sb'

# for looking at a commit
alias gs='git show'

# show stat
alias ss='git show --stat'

alias gb='git branch'
alias gba='git branch -a'

function interactive_rebase()
{
	if [ -z "$1" ]; then
		git rebase -i $(get_branch)
	else
		git rebase -i HEAD~$1
	fi
}

alias gr='interactive_rebase'

function next_commit_changes()
{
	out=$(git log --numstat --pretty=format: -n1 | tail -n+1)
	echo "$out" | awk '{printf("%s ", $3)}'
}

function diff_branch()
{
	echo "Changes in this commit:"
	echo
	git log --stat --oneline -n1

	echo
	echo "Now performing diff against branch on those files only"

	# print a stat list first
	echo $(next_commit_changes)
	git diff $1 --stat -- $(next_commit_changes)

	# now run meld on each diff
	git diff $1 -- $(next_commit_changes)
}

# db <branch>

# this is for splitting a large commit into multiple ones

# Usage:
# git checkout mmc2
# git rebase -i HEAD~4
# on a commit use:
# db mmc2
# this will print a list of changes to the files used by THIS commit
# which have been made at mmc2
alias db='diff_branch'

alias rhard='git reset --hard HEAD'
alias gp='git cherry-pick'

function show_commit()
{
	git diff $1~..$1
}
alias sd='show_commit'
alias gd='git diff'
alias gdc='git diff --cached'
alias gc='git commit'
alias co='git checkout'

function do_tag_archive()
{
	git show $1 |head -5 && git tag archive/$1-$(date +%d-%b-%y) $1 && git branch -D $1
}

alias tag_archive='do_tag_archive $1'

alias gl='git log'
alias glo='git log --oneline --decorate'

# set_upstream [upstream_branch]
# Sets the upstream branch for the current branch
# If arg is omitted, will use m/master
function set_upstream()
{
	branch=$(git name-rev HEAD --name-only)

	upstream=${1-m/master}
#	echo ${upstream} ${branch}
	if [ -n ${branch} ]; then
#		if ! git branch --set-upstream-to ${branch}/${upstream}; then
		git branch --set-upstream-to ${upstream} ${branch}
#		     	echo bad
#			commits=$(glo -n100 |grep -n git5 | sed 's/:.*//')
#			echo ${commits}
#			git branch -D us-git5
#			git branch us-git5 HEAD~$(($commits - 1))
#		fi
	else
		echo "Cannot test current branch"
	fi
}

alias us='set_upstream'
alias et='git rebase --edit-todo'


function fix_kconfig()
{
	crosfw -b $1 cfg && \
	make O=/tmp/b/$1 savedefconfig && \
	meld /tmp/b/$1/defconfig configs/$1_defconfig
}

alias fix-kconfig='fix_kconfig'

alias pe='git log --oneline -n10 --decorate'

alias pm='patch -p1 --merge <.git/rebase-apply/patch'

alias good='git bisect good'
alias bad='git bisect bad'
alias rb='git rebase m/master'

alias mg='git log --oneline us/master | grep $1'
